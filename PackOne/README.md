## C++实现壳

![260](http:\\github.com\havocykp\15pb-Project\PackOne\image\260.png)

### 功能

#### 1.在原程序中添加一块区段，将壳部分的代码移植进去

#### 2.在程序启动前优先获得控制权，执行完自己的代码以后再将控制权交还给原程序

#### 3.对代码段进行加密

#### 4.对原程序的导入表（IAT）进行修复

#### 5.如果原程序开启了随机基址，则对原程序进行重定位修复

 

### 程序分为两部分

- 壳程序

  - 读取 PE文件信息并保存

    > 加载文件到内存，方式：
    >
    > 1. 以文件对齐的方式
    >
    > 2. 以内存对齐的方式（模拟程序运行时的内存分布，好处就是对PE文件进行操作时，不需要将`相对虚拟地址（RVA）`转换为`文件偏移（Offset）`）
    >
    >

  - 加密代码段操作

  - 将必要的信息保存到Shell

    > 对PE文件进行操作分两个时候：
    >
    > 1. 加壳前的操作
    > 2. 加完壳、程序运行时

  - 将Shell部分附加到PE文件

    - 读取Shell代码

      > 通过LoadLibrary(L"Shell.dll")的方式加载

    - 设置Shell重定位信息

      > 由于Shell部分是Dll，默认加载基址是0x1000000，而要将Dll文件移植到exe文件（默认加载基址0x400000）,再加上有些程序有随机基址，所以要执行Shell部分的代码，进行重定位是必须的
      >
      > 重定位的实现方式：
      >
      > 1. 系统的PE加载器通过重定位表的信息，在加载程序之前重定位
      > 2. 用代码进行手动重定位，模拟PE加载器所进行的重定位操作
      >
      > *让系统重定位 Shell部分的代码，保证 Shell部分的函数可以正常执行*
      >
      > *在 Shell部分手动重定位原程序代码，让原程序能够执行*
      >
      >
      >
      > 如何重定位 Shell部分的代码？
      >
      > 由于Shell部分的代码是通过LoadLibrary(L"Shell.dll")的方式加载的，这说明加载到内存中之前，PE加载器已经帮我们修复过重定位了。而我们现在再去访问重定位表的信息的时候，是已经修复过的正确的重定位信息，而我们想要的是原始的重定位信息，把原始的重定位信息写入加壳后的文件，当PE加载器运行被加壳程序的时候，才能通过原始的重定位信息给我们的Shell部分进行正确的重定位，所以首先就是恢复重定位之前的原始信息。
      >
      >

    - 修改被加壳程序的OEP，指向Shell

      > 让程序运行时，从Shell部分开始执行

    - 合并PE文件和Shell的代码到新的缓冲区

      > 目前内存中有两个缓冲区，一个是原PE程序的缓冲区，另一个是Shell部分的缓冲区，我们要做的就是重新申请一块连续的空间，大小为这两个缓冲区的大小，然后将他们拷贝进去。内存中这样处理是没问题的，这时如果保存这个缓冲区的话就是两个文件的结合体，但逻辑上并没有如此简单，因为从物理上多出来一个Shell区段，但逻辑上并没有变，也就是系统并不认识这个新加的Shell区段，这时候就又需要去修改PE文件信息了，这次需要修改的是区段表中的信息，涉及到新增一个区段目录表信息，并正确设置该区段的起始地址、大小等信息，而且在设置这些信息的时候还要考虑到文件对齐的问题

  - 保存文件，完成加壳

  - 释放资源

- 外壳程序

  - 获取Shell部分所用的函数

    > 有很多壳为了隐藏自己的行为，不让别人看出它用到了哪些函数，直接没有导入表，
    >
    > 不让PE加载器为其导入函数。而是直接自己动态获取所用到的函数
    >
    > 无论一个PE文件是否有导入表，系统都会为其加载两个模块，ntdll.dll 和 kernel32.dll，那么就从这两个模块入手，目标是获取GetProcAddress()这个函数，而这个函数位于kernel32.dll中，首先要做的就是获取kernel32.dll的加载基址，常用方法有三种：
    >
    > 1. 通过特征匹配的暴力搜索
    > 2. 利用系统的SEH机制
    > 3. 通过线程环境块TEB
    >
    > 当获取了kernel32.dll的加载基址后，就可以通过遍历kernel32.dll的**导出表**来搜索GetProcAddress()，从而获取该函数的地址，然后在获取LoadLibraryA()的函数地址，这样就可以任意的加载模块了
    >
    >

  - 解密代码段

  - 修复原程序的重定位信息

    >  由于加壳程序的重定位指针指向了Shell部分的重定位，PE加载器在加载PE文件的时候对Shell部分的代码进行了重定位，所以本应给原程序进行的重定位就需要我们在Shell部分实现了，此项目原程序的重定位表并没有遭到破坏(有些壳会对重定位表进行破坏或加密)，所以我们只要在Pack部分加壳的时候保存一下原程序的重定位表指针，然后在Shell部分对这个指针所指向的重定位表进行重定位就可以了，其实就是在模拟PE加载器的重定位操作。
    >
    > 原程序的重定位表指针在Pack的时候有保存过，这里直接拿来用就可以了。
    > 重定位表最终指向的是一个需要重定位的地址，这个地址是基于原PE文件默认基址(一般为0x00400000)的地址，原PE文件的默认基址我们也有保存过，所以修复起来还是比较方便的，只需要遍历原PE文件的重定位表，然后通过一个公式计算出重定位后的地址再填充回去就可以了。
    > 计算公式：重定位后的地址=需要重定位的地址-默认加载基址+当前真实的加载基址。
    >
    > 还有一点需要注意的是，在修复的时候所修复的地址的内存属性不一定是可写的，所以最好在修复之前用VirtualProtect()修改内存属性为可写，修复完以后再将原来的属性设置回去。
    >
    >

  - 修复原程序的导入表（IAT）信息

    > 导入表的用途是保存该PE文件用到的API函数的信息，由于每次启动程序时这些API函数的加载地址可能会不一样，所以PE文件中无法直接保存一个函数地址，而是保存这些函数的信息，当启动程序时，PE加载器会通过导入表信息为其加载所用到的模块，并获取需要调用的API函数的地址，再将该地址填充到IAT，这样程序才能正常的调用API。由于修复导入表最终是为了填充IAT(只要IAT中的函数地址正确，没有导入表信息也可以)，所以又叫做修复IAT，这项技术不仅仅加壳时修复原程序的IAT，在脱壳的时候也会用到IAT修复，只有正确修复了IAT才能让程序正常运行，所以很多壳会在IAT加密上做文章，来防止脱壳成功。
    >
    > 此项目中没有破换原有PE文件的导入表信息，所以在Pack的时候保存导入表指针就可以找到导入表信息。有人会问，那为什么不直接让PE加载器来修复呢，其实这样也是可以的，只要你填写正确的导入表指针信息，系统PE加载器就可以帮你修复，但壳很少会这么做
    >
    >
    >
    > 修复IAT过程：
    >
    > 通过导入表 指针遍历导入表信息，里面保存着需要导入的函数的名称和所在模块，所要做的就是加载这些模块，并从中获取函数地址，然后添加到正确的IAT位置即可
    >
    > 加载模块和获取函数地址这两个函数之前通过自定义函数指针的方式已经获取到了，那么剩下的就是遍历导入表了

  - 跳转到程序入口点，将控制权交还给程序

    > 经过修复重定位和修复IAT的操作后，原PE文件就可以正常运行了，在跳回到原程序入口点之前把想做的事做完