#include <stdio.h>
#include <tchar.h>

 /*
 * BeaEngine反汇编引擎的使用
 * 将opcode转换为指令
 **/

// 需要添加的宏
#define BEA_ENGINE_STATIC
#define BEA_USE_STDCALL

// 包含BeaEngine的头文件
#include "BeaEngine_4.1/Win32/headers/BeaEngine.h"

// 包含对应版本的静态库
#pragma comment(lib, "BeaEngine_4.1\\Win32\\Win32\\Lib\\BeaEngine.lib")

// 防止编译错误
#pragma comment(linker, "/NODEFAULTLIB:\"crt.lib\"")

// 打印opcode
void printOpcode(const unsigned char* pOpcode/*缓冲区首地址*/, int nSize/*字节数*/)
{
	for (int i = 0; i < nSize; ++i)
	{
		printf("%02X ", pOpcode[i]);
	}
}
int _tmain(int argc, _TCHAR *argv[])
{
	DISASM disAsm = { 0 };

	unsigned char opcode[] = 
	{

		0x6B, 0x4C, 0x73, 0x45, 0x00, 0x00, 0x00, 0x01, 0x90, 0x5C, 0x4D, 0x77, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x17, 0x3C, 0x77, 0x60, 0x77, 0x42, 0x77, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x84, 0x17, 0x3C, 0x77, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x57, 0x14, 0x01, 0xE2, 0x46, 0x15, 0xC5, 0x43, 0xA5, 0xFE, 0x00, 0x8D,
		0xEE, 0xE3, 0xD3, 0xF0, 0x06, 0x00, 0x00, 0x00, 0x48, 0x6E, 0x3C, 0x77, 0x01, 0x00, 0x00, 0x00,
		0x9A, 0x8B, 0x13, 0x35, 0x96, 0x5D, 0xBD, 0x4F, 0x8E, 0x2D, 0xA2, 0x44, 0x02, 0x25, 0xF9, 0x3A,
		0x06, 0x00, 0x01, 0x00, 0x2C, 0x6E, 0x3C, 0x77, 0x02, 0x00, 0x00, 0x00, 0xE3, 0x28, 0x2F, 0x4A,
		0xB9, 0x53, 0x41, 0x44, 0xBA, 0x9C, 0xD6, 0x9D, 0x4A, 0x4A, 0x6E, 0x38, 0x06, 0x00, 0x02, 0x00,
		0x10, 0x6E, 0x3C, 0x77, 0x03, 0x00, 0x00, 0x00, 0x76, 0x6C, 0x67, 0x1F, 0xE1, 0x80, 0x39, 0x42,
		0x95, 0xBB, 0x83, 0xD0, 0xF6, 0xD0, 0xDA, 0x78, 0x06, 0x00, 0x03, 0x00, 0xF4, 0x6D, 0x3C, 0x77,
		0x04, 0x00, 0x00, 0x00, 0x12, 0x7A, 0x0F, 0x8E, 0xB3, 0xBF, 0xE8, 0x4F, 0xB9, 0xA5, 0x48, 0xFD,
		0x50, 0xA1, 0x5A, 0x9A, 0x0A, 0x00, 0x00, 0x00, 0xD0, 0x6D, 0x3C, 0x77, 0x18, 0x00, 0x1A, 0x00,
		0xC0, 0x6E, 0x3C, 0x77, 0x80, 0xA4, 0x41, 0x77, 0x20, 0x36, 0x3E, 0x77, 0x00, 0x00, 0x00, 0x00,
		0x50, 0x7E, 0x4B, 0x77, 0x08, 0x00, 0x0A, 0x00, 0x88, 0x76, 0x3C, 0x77, 0x08, 0x00, 0x0A, 0x00,
		0xA0, 0x77, 0x3C, 0x77, 0x02, 0x00, 0x04, 0x00, 0x00, 0x7A, 0x3C, 0x77, 0x06, 0x00, 0x08, 0x00,
		0x28, 0x7A, 0x3C, 0x77, 0x06, 0x00, 0x08, 0x00, 0x20, 0x7A, 0x3C, 0x77, 0x06, 0x00, 0x08, 0x00,
		0x18, 0x7A, 0x3C, 0x77, 0x06, 0x00, 0x08, 0x00, 0x30, 0x7A, 0x3C, 0x77, 0x0E, 0x00, 0x10, 0x00,
		//"F026C7 8491AA000000 11000000"
	};

	// 配置结构体，初始化反汇编的opcode
	disAsm.EIP = (UIntPtr)opcode; // 保存opcode的缓冲区首地址
	disAsm.VirtualAddr = 0x401080; // opcode指令的地址
	disAsm.Archi = 0; // 0 -->32, 1-->64
	disAsm.Options = 0x000; // masm 汇编指令格式

	int nOpcodeSize = sizeof(opcode); // opcode的字节数

	int nCount = 0; // 用于记录在循环当中，反汇编了多少字节
	int nLen = 0; // 用于记录当前的汇编指令的字节数

	// 调用Disasm()进行反汇编
	while (nCount < nOpcodeSize)
	{
		nLen = Disasm(&disAsm); // 每次只反汇编一条汇编指令，
								// 并返回当前得到的汇编指令的长度

		unsigned int uAddr = disAsm.VirtualAddr;
		printf("%08X | ", uAddr); // 打印地址
		printOpcode((const unsigned char*)disAsm.EIP, nLen); // 打印opcode
		printf(" | %s\n", disAsm.CompleteInstr); // 打印反汇编指令

		nCount += nLen; // 累加已经反汇编的字节数
		disAsm.EIP += nLen; // 定位到下一条汇编指令
		disAsm.VirtualAddr += nLen; // 设置到下一条汇编指令的地址
	}
	
	system("pause");
	return 0;
}